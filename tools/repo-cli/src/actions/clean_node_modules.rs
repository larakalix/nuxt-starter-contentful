use anyhow::Result;
use std::{fs, path::PathBuf};

use crate::{
    app::AppState,
    fs::{walker, size},
};

pub fn run(app: &mut AppState) -> Result<()> {
    app.clear_output_for_action("Clean node_modules");
    app.set_busy(true);

    let mut targets: Vec<PathBuf> = Vec::new();

    // Root node_modules
    let root_nm = PathBuf::from("node_modules");
    if root_nm.exists() {
        targets.push(root_nm);
    }

    // apps/**/node_modules
    if std::path::Path::new("apps").exists() {
        targets.extend(walker::find_dirs_named("apps", "node_modules")?);
    }

    // packages/**/node_modules
    if std::path::Path::new("packages").exists() {
        targets.extend(walker::find_dirs_named("packages", "node_modules")?);
    }

    if targets.is_empty() {
        app.log("âœ… No node_modules folders found");
        app.set_busy(false);
        return Ok(());
    }

    app.log(format!("ğŸ§¹ Found {} node_modules folders", targets.len()));
    app.log("");

    // ğŸ” SIZE ESTIMATION
    let mut total_size: u64 = 0;

    for path in &targets {
        let size_bytes = size::dir_size(path)?;
        total_size += size_bytes;

        app.log(format!(
            "ğŸ“¦ {} â†’ {}",
            path.display(),
            size::format_bytes(size_bytes)
        ));
    }

    app.log("");
    app.log(format!(
        "ğŸ’¾ Total size to free: {}",
        size::format_bytes(total_size)
    ));
    app.log("");

    // ğŸ§ª DRY RUN
    if app.dry_run {
        app.log("ğŸ§ª Dry run enabled â€” no files will be deleted");
        app.set_busy(false);
        return Ok(());
    }

    // ğŸ—‘ï¸ DELETE
    for path in targets {
        app.log(format!("ğŸ—‘ï¸  Removing: {}", path.display()));
        let _ = fs::remove_dir_all(&path);
    }

    app.log("");
    app.log("âœ… node_modules cleanup completed");
    app.set_busy(false);

    Ok(())
}
